<!-- Licensed under a BSD license. See license.html for license -->
<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- ATTN: Project 1A, Task 0 == Change the name of the window -->
    <title>CAP5705 - Project1 Lastname,FirstName(ufid)</title>
</head>
<style>
    canvas {
        border: 1px solid black;
        width: 1024px;
        height: 768px;
    }
</style>

<body>
    <div class="description">
        Scaffold Code for Project 1
    </div>
    <canvas id="canvas"></canvas>
    <div id="info"></div>
</body>
</body>
<!--
This sample uses TWGL (Tiny WebGL) to hide the clutter.
Otherwise the sample would be full of code not related to the point of the sample.
For more info see https://webgl2fundamentals.org/webgl/lessons/webgl-less-code-more-fun.html
-->
<script src="resources/twgl-full.min.js"></script>
<script src="resources/m4.js"></script>
<script src="resources/webgl-utils.js"></script>
<script type="text/javascript" src="https://spectorcdn.babylonjs.com/spector.bundle.js"></script>
<script>
    "use strict";
    var spector = new SPECTOR.Spector();
    spector.displayUI();

    const vs = `#version 300 es
      // Input vertex data, different for all executions of this shader.
      // The "a_" prefix denotes an attribute (the glsl 330 "layout" equivalent)
      in vec4 a_vertexPosition_modelspace;
      in vec4 a_vertexColor;

      // Output data ; will be interpolated for each fragment.
      out vec4 vs_vertexColor;

      // Values that stay constant for the whole mesh.
      uniform mat4 u_MVP;
      uniform mat4 u_V;
      uniform mat4 u_M;

      void main(){
          gl_PointSize = 40.0;
          // Output position of the vertex, in clip space : MVP * position
          gl_Position =  u_MVP * a_vertexPosition_modelspace;

          vs_vertexColor = a_vertexColor;
      }
      `;

    const fs = `#version 300 es
        precision highp float;

        // Interpolated values from the vertex shaders
        in vec4 vs_vertexColor;

        // Ouput data
        out vec3 color;

        void main(){
            color = vs_vertexColor.rgb;
        }
    `;

    const pickingVS = `#version 300 es
      in vec4 a_vertexPosition_modelspace;
      
      out vec4 vs_vertexColor;

      // Values that stay constant for the whole mesh.
      uniform float u_PickingColorArray[8]; // picking ID mark (one per vertex/point)
      uniform mat4 u_MVP;

      void main() {
          gl_PointSize = 40.0; 

          vs_vertexColor = vec4(u_PickingColorArray[gl_VertexID], 0.0, 0.0, 1.0); // set color based on the ID mark

          // Output position of the vertex, in clip space : MVP * position
          gl_Position = u_MVP * a_vertexPosition_modelspace;
      }
      `;

    const pickingFS = `#version 300 es
      precision highp float;

      in vec4 vs_vertexColor;

      // Ouput data
      out vec4 color;

      void main(){
          color = vs_vertexColor;
      }   
      `;

    // ATTN 1A is the general place in the program where you have to change the code base to satisfy a Task of Project 1A.
    // ATTN 1B for Project 1B. ATTN 1C for Project 1C. Focus on the ones relevant for the assignment you're working on.

    class Vertex {
        Position = new Float32Array(4);
        Color = new Float32Array(4);
        byteLength = Number(this.Position.byteLength + this.Color.byteLength);
        SelectedColor = new Float32Array(4);
        isSelected = false;
        isSwapped = false;
        constructor(pos, color) {
            this.Position = Array.from(pos);
            this.Color = Array.from(color);
            this.SetSelectedColor();
        };
        SetCoords = function (coords) {
            this.Position[0] = coords[0];
            this.Position[1] = coords[1];
            this.Position[2] = coords[2];
            this.Position[3] = coords[3];
        };
        SetColor = function (color) {
            this.Color[0] = color[0];
            this.Color[1] = color[1];
            this.Color[2] = color[2];
            this.Color[3] = color[3];
        };
        SetSelectedColor() {

            this.SelectedColor[0] = 0.3;
            this.SelectedColor[1] = 0.6;
            this.SelectedColor[2] = 0.9;
            this.SelectedColor[3] = 1.0;
        }
    };

    function VerticesFlatten(Vertices) {
        var arr = Array.from(Vertices);
        var arr1 = [];
        arr.forEach(vert => arr1.push([vert.Position, vert.Color]));
        var arr2 = arr1.flat(Infinity);
        return new Float32Array(arr2);
    };

    // ATTN: use POINT structs for cleaner code (POINT is a part of a vertex)
    // allows for (1-t)*P_1+t*P_2  avoiding repeat for each coordinate (x,y,z)
    class point {
        x = 0;
        y = 0;
        z = 0;
        constructor(x = 0, y = 0, z = 0) {
            this.x = x;
            this.y = y;
            this.z = z;
        }
        point(coords) {
            this.x = coords[0];
            this.y = coords[1];
            this.z = coords[2];
        }
    };
    point.prototype["-"] = function (a) {
        return point(this.x - a.x, this.y - a.y, this.z - a.z);
    }
    point.prototype["+"] = function (a) {
        return point(this.x + a.x, this.y + a.y, this.z + a.z);
    }
    point.prototype["*"] = function (a) {
        return point(this.x * a, this.y * a, this.z * a);
    }
    point.prototype["/"] = function (a) {
        return point(this.x / a, this.y / a, this.z / a);
    }
    point.prototype.toArray = function () {
        array = new Array(x, y, z, 1.0);
        return array;
    }

    //GLOBAL VARIABLES
    const viewProjectionMatrix = m4.identity();

    // Camera Variables
    const cameraPosition = [0, 0, -5];
    const target = [0, 0, 0];
    const up = [0, 1, 0];
    const viewMatrix = m4.lookAt(cameraPosition, target, up);

    // ATTN: INCREASE THIS NUMBER AS YOU CREATE NEW OBJECTS
    const NumObjects = 1; // Number of object types in the scene

    // Keeps track of IDs associated with each object
    const VertexArrayId = new Array(NumObjects);
    const VertexBufferId = new Array(NumObjects);
    const IndexBufferId = new Array(NumObjects);

    const VertexBufferSize = new Uint8Array(NumObjects);
    const IndexBufferSize = new Uint8Array(NumObjects);
    const NumVerts = new Uint8Array(NumObjects); // Useful for glDrawArrays command
    const NumIdcs = new Uint8Array(NumObjects); // Useful for glDrawElements command

    // Initialize ---  global objects -- not elegant but ok for this project
    const IndexCount = 8;
    const Vertices = new Array(IndexCount);
    const Indices = new Uint16Array(IndexCount);

    // ATTN: DON'T FORGET TO INCREASE THE ARRAY SIZE IN THE PICKING VERTEX SHADER WHEN YOU ADD MORE PICKING COLORS
    const pickingColor = new Float32Array(IndexCount);
    let gPickedIndex;

    const angle = Math.PI* 2/IndexCount;
    function createObjects(Vertices, Indices) {

        let radius = 1.0;
        // ATTN: DERIVE YOUR NEW OBJECTS HERE:  each object has
        // an array of vertices {pos;color} and
        // an array of indices (no picking needed here) (no need for indices)

        // ATTN: Project 1A, Task 1 == Add the points in your scene
        Vertices[0] = new Vertex([0.0, 0.0, 0.0, 1.0], [1.0, 0.0, 0.0, 1.0]);
        Vertices[1] = new Vertex([-1.0, 1.0, 0.0, 1.0], [0.0, 1.0, 0.0, 1.0]);
        Vertices[2] = new Vertex([-1.0, -1.0, 0.0, 1.0], [0.0, 0.0, 1.0, 1.0]);
        Vertices[3] = new Vertex([1.0, -1.0, 0.0, 1.0], [1.0, 1.0, 1.0, 1.0]);
        Vertices[4] = new Vertex([2.0, 2.0, 0.0, 1.0], [1.0, 1.0, 0.0, 1.0]);
        Vertices[5] = new Vertex([-2.0, 2.0, 0.0, 1.0], [0.0, 1.0, 1.0, 1.0]);
        Vertices[6] = new Vertex([-2.0, -2.0, 0.0, 1.0], [1.0, 0.0, 1.0, 1.0]);
        Vertices[7] = new Vertex([2.0, -2.0, 0.0, 1.0], [0.0, 0.0, 0.0, 1.0]);

        for(var i = 0 ; i < IndexCount ; i++) {

            let newX = radius * Math.sin(angle * i);
            let newY = radius * Math.cos(angle * i);
            Vertices[i].Position[0] = newX;
            Vertices[i].Position[1] = newY;
        }


        for(var i = 0 ; i < IndexCount ; i++) {

            Indices[i] = i;
        }

        // ATTN: Project 1B, Task 1 == create line segments to connect the control points

        // ATTN: Project 1B, Task 2 == create the vertices associated to the smoother curve generated by subdivision

        // ATTN: Project 1B, Task 4 == create the BB control points and apply De Casteljau's for their corresponding for each piece

        // ATTN: Project 1C, Task 3 == set coordinates of yellow point based on BB curve and perform calculations to find
        // the tangent, normal, and binormal
    };

    // this actually creates the VAO (structure) and the VBO (vertex data buffer)
    function createVAOs(gl, mainShader, Vertices, Indices, ObjectId) {
        //See less-code-more-fun-drawbufferinfo for an interesting alternative AFTER you understand the below

        const VertexSize = Vertices[0].byteLength;
        const RgbOffset = Vertices[0].Position.length * Float32Array.BYTES_PER_ELEMENT;

        // Create Vertex Array Object
        VertexArrayId[ObjectId] = gl.createVertexArray();
        gl.bindVertexArray(VertexArrayId[ObjectId]);

        // Create buffer for vertex data
        VertexBufferId[ObjectId] = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, VertexBufferId[ObjectId]);
        gl.bufferData(gl.ARRAY_BUFFER, VerticesFlatten(Vertices), gl.STATIC_DRAW);

        // Create buffer for indices
        if (Indices != null) {
            IndexBufferId[ObjectId] = gl.createBuffer();
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, IndexBufferId[ObjectId]);
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(Indices), gl.STATIC_DRAW);
        }

        const positionLoc = gl.getAttribLocation(mainShader.program, "a_vertexPosition_modelspace");
        const colorLoc = gl.getAttribLocation(mainShader.program, "a_vertexColor");

        gl.enableVertexAttribArray(positionLoc);
        gl.enableVertexAttribArray(colorLoc);
        // Assign vertex attributes
        gl.vertexAttribPointer(
            positionLoc, // location
            4, // size (num values to pull from buffer per iteration)
            gl.FLOAT, // type of data in buffer
            false, // normalize
            VertexSize, // stride (0 = compute from size and type above)
            0, // offset in buffer
        );
        gl.vertexAttribPointer(colorLoc, 4, gl.FLOAT, false, VertexSize, RgbOffset);

    }

    function makeFramebufferAndTexture(gl, width, height) {
        // create a framebuffer
        const framebuffer = gl.createFramebuffer();
        gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);

        // create a depth renderbuffer
        const depthBuffer = gl.createRenderbuffer();
        gl.bindRenderbuffer(gl.RENDERBUFFER, depthBuffer);
        gl.renderbufferStorage(
            gl.RENDERBUFFER, gl.DEPTH_COMPONENT16,
            width, height);

        const texture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, texture);
        gl.texImage2D(gl.TEXTURE_2D,
            0,       // level
            gl.RGBA, // internal format
            width,
            height,
            0,       // border
            gl.RGBA, // format
            gl.UNSIGNED_BYTE, // type
            null,    // data (no data needed)
        );

        gl.framebufferTexture2D(
            gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0,
            gl.TEXTURE_2D, texture, 0 /* level */);
        // make a depth buffer and the same size as the targetTexture
        gl.framebufferRenderbuffer(
            gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT,
            gl.RENDERBUFFER, depthBuffer);

        return {
            framebuffer,
            texture,
            width,
            height,
        };
    }

    function main() {
        // Get A WebGL context
        /** @type {HTMLCanvasElement} */
        const canvas = document.getElementById("canvas");
        const gl = canvas.getContext("webgl2", {
            alpha: false //ATTN: see https://webgl2fundamentals.org/webgl/lessons/webgl-and-alpha.html
        });
        if (!gl) {
            return;
        }
        webglUtils.resizeCanvasToDisplaySize(gl.canvas);

        // Set-up Framebuffer
        makeFramebufferAndTexture(gl, gl.canvas.width, gl.canvas.height);

        // create viewport
        gl.viewport(0, 0, gl.canvas.clientWidth, gl.canvas.clientHeight);

        // background color
        gl.clearColor(0.0, 0.0, 0.4, 0.0);

        // Enable depth test
        gl.enable(gl.DEPTH_TEST);
        // Accept fragment if it closer to the camera than the former one
        gl.depthFunc(gl.LESS);
        // Cull triangles which normal is not towards the camera
        gl.enable(gl.CULL_FACE);

        // setup GLSL program
        const programInfo = twgl.createProgramInfo(gl, [vs, fs]);
        const pickingProgramInfo = twgl.createProgramInfo(gl, [pickingVS, pickingFS]);

        // Define pickingColor array for picking program
        // use a for-loop here

        for(var i = 0 ; i < IndexCount ; i++) {

            pickingColor[i] = i/255.0;
        }
        // Define objects
        createObjects(Vertices, Indices);

        // ATTN: create VAOs for each of the newly created objects here:
        // for several objects of the same type use a for-loop
        const obj = 0; // initially there is only one type of object 
        VertexBufferSize[obj] = VerticesFlatten(Vertices).byteLength;
        IndexBufferSize[obj] = Indices.bytelength;
        NumIdcs[obj] = IndexCount;

        createVAOs(gl, programInfo, Vertices, Indices, obj);

        function DrawObjects() {
            // Dark blue background
            gl.clearColor(0.0, 0.0, 0.4, 0.0);

            // Re-clear the screen for visible rendering
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

            gl.useProgram(programInfo.program); {
                // see comments in pick
                const uniforms = {
                    u_M: m4.identity(),
                    u_V: viewMatrix,
                    u_MVP: viewProjectionMatrix,
                };

                twgl.setUniforms(programInfo, uniforms);
                // gl.bindBuffer(gl.ARRAY_BUFFER,VertexBufferId[0]);
                gl.bindVertexArray(VertexArrayId[0]); // Draw Vertices
                gl.bufferSubData(gl.ARRAY_BUFFER, 0, VerticesFlatten(Vertices)); // Update buffer data
                gl.drawElements(gl.POINTS, NumIdcs[0], gl.UNSIGNED_SHORT, 0);

                // If don't use indices
                //gl.drawArrays(gl.POINTS, 0, NumVerts[0]);

                // ATTN: OTHER BINDING AND DRAWING COMMANDS GO HERE
                // one set per object:
                // gl.bindVertexArray(VertexArrayId[<x>]); etc etc

                // ATTN: Project 1C, Task 2 == Refer to https://learnopengl.com/Getting-started/Transformations and
                // https://learnopengl.com/Getting-started/Coordinate-Systems - draw all the objects associated with the
                // curve twice in the displayed fashion using the appropriate transformations

                gl.bindVertexArray(null);
            }
            gl.useProgram(null);
        }

        // mouseX and mouseY are in CSS display space relative to canvas
        let mouseX = -1;
        let mouseY = -1;
        let oldPickNdx = -1;
        let oldPickColor;
        let frameCount = 0;

        function pickVertex() {
            // Clear the screen in white
            gl.clearColor(1.0, 1.0, 1.0, 1.0);

            // Clear the canvas AND the depth buffer.
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

            const PickingMatrixID = gl.getUniformLocation(pickingProgramInfo.program, 'u_MVP');
            const pickingColorArrayID = gl.getUniformLocation(pickingProgramInfo.program, 'u_PickingColorArray');

            gl.useProgram(pickingProgramInfo.program); {
                // Compute the projection matrix
                const projectionMatrix =
                    m4.orthographic(-4.0, 4.0, -3.0, 3.0, 0.0, 100.0);
                m4.multiply(projectionMatrix, viewMatrix, viewProjectionMatrix);
                const ModelMatrix = m4.identity();
                // ModelMatrix == TranslationMatrix * RotationMatrix;
                let MVP = m4.identity();
                MVP = m4.multiply(viewProjectionMatrix, ModelMatrix);
                // MVP should really be PVM...
                // Send the MVP to the shader (that is currently bound)
                // as data type uniform (shared by all shader instances)

                gl.uniformMatrix4fv(PickingMatrixID, false, new Float32Array(MVP));

                // pass in the picking color array to the shader
                gl.uniform1fv(pickingColorArrayID, pickingColor);

                // --- enter vertices into VBO and draw
                gl.bindVertexArray(VertexArrayId[0]);
                gl.bufferSubData(gl.ARRAY_BUFFER, 0, VerticesFlatten(Vertices)); // Update buffer data
                gl.drawElements(gl.POINTS, NumIdcs[0], gl.UNSIGNED_SHORT, 0);
                gl.bindVertexArray(null);
            }
            gl.useProgram(null);
            gl.flush();
            // --- Wait until all the pending drawing commands are really done.
            // Ultra-mega-over slow ! 
            // There are usually a long time between glDrawElements() and
            // all the fragments completely rasterized.
            gl.finish();

            gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);

            // --- Read the pixel at the center of the screen.
            // You can also use glfwGetMousePos().
            // Ultra-mega-over slow too, even for 1 pixel, 
            // because the framebuffer is on the GPU.
            const xpos = mouseX * gl.canvas.width / gl.canvas.clientWidth;
            const ypos = gl.canvas.height - mouseY * gl.canvas.height / gl.canvas.clientHeight - 1;
            const data = new Uint8Array(4);
            gl.readPixels(
                xpos, // x
                ypos, // y
                1, // width
                1, // height
                gl.RGBA, // format
                gl.UNSIGNED_BYTE, // type
                data); // typed array to hold result
            // window_height - ypos;  
            // OpenGL renders with (0,0) on bottom, mouse reports with (0,0) on top


            // Convert the color back into an integer ID
            gPickedIndex = data[0];

            if(gPickedIndex >= IndexCount) {

                for(var i = 0 ; i < IndexCount ; i++) {


                    Vertices[i].isSelected = false;
                }
            }
            else {

                    Vertices[gPickedIndex].isSelected = true;
            }

            for(var i = 0 ; i < IndexCount ; i++) {

                if(Vertices[i].isSelected) {

                    for(var j = 0 ; j < 4 ; j++) {

                        [Vertices[i].Color[j], Vertices[i].SelectedColor[j]] = [Vertices[i].SelectedColor[j], Vertices[i].Color[j]];
                    }
                }
            }

            // ATTN: Project 1A, Task 2
            // Find a way to change color of selected vertex and
            // store original color
        }

        function scaleX(x) {

            return ((4 - (-4)) * (x - 0))/ (1024 - (0)) + (-4);
        }

        function scaleY(y) {

            return ((3 - (-3)) * (y - 0))/ (768 - (0)) + (-3);
        }

        // ATTN: Project 1A, Task 3 == Retrieve your cursor position, get corresponding world coordinate, and move the point accordingly

        // ATTN: Project 1C, Task 1 == Keep track of z coordinate for selected point and adjust its value accordingly based on if certain
        // buttons are being pressed
        function moveVertex() {
            const ModelMatrix = m4.identity();
            var viewport = new Array(4);
            viewport = gl.getParameter(gl.VIEWPORT);

            var w = canvas.clientWidth;
            var h = canvas.clientHeight;

            const vp = [viewport[0], viewport[1], viewport[2], viewport[3]];


            const xpos = mouseX * gl.canvas.width / gl.canvas.clientWidth;
            const ypos = gl.canvas.height - mouseY * gl.canvas.height / gl.canvas.clientHeight;

            var x = scaleX(xpos);
            var y = scaleY(ypos);

            if (gPickedIndex >= IndexCount) {
                // Any number > vertices-indices is background!
                console.log("background");
            } else {
                console.log("point " + gPickedIndex);

                for(var i = 0 ; i < IndexCount ; i++) {

                    if(Vertices[i].isSelected) {

                        Vertices[i].Position[0] = -x;
                        Vertices[i].Position[1] = y;
                    }
                }
            }
        }

        // Draw the scene.
        function drawScene(time) {
            time *= 0.0005;
            ++frameCount;

            // ------ Draw the objects to the canvas
            {
                // Compute the projection matrix
                const projectionMatrix =
                    m4.orthographic(-4.0, 4.0, -3.0, 3.0, 0.0, 100.0);
                m4.multiply(projectionMatrix, viewMatrix, viewProjectionMatrix);
            }
            // ------ Draw the objects to the canvas

            gl.bindFramebuffer(gl.FRAMEBUFFER, null);
            gl.viewport(0, 0, gl.canvas.clientWidth, gl.canvas.clientHeight);

            DrawObjects();

            requestAnimationFrame(drawScene);
        }
        requestAnimationFrame(drawScene);

        // DRAGGING: move current (picked) vertex with cursor
        gl.canvas.addEventListener('mousedown', (e) => {
            const rect = canvas.getBoundingClientRect();
            mouseX = e.clientX - rect.left;
            mouseY = e.clientY - rect.top;

            pickVertex();

            moveVertex();
        });

        gl.canvas.addEventListener('mousemove', (e) => {

            const rect = canvas.getBoundingClientRect();
            mouseX = e.clientX - rect.left;
            mouseY = e.clientY - rect.top;

            moveVertex();
        })

        gl.canvas.addEventListener('mouseup', (e) => {

            for(var i = 0 ; i < IndexCount ; i++) {

                if(Vertices[i].isSelected) {

                    for(var j = 0 ; j < 4 ; j++) {

                        [Vertices[i].Color[j], Vertices[i].SelectedColor[j]] = [Vertices[i].SelectedColor[j], Vertices[i].Color[j]];
                    }
                    Vertices[i].isSelected = false;
                }
            }
        });
    }

    main();
</script>

</html>